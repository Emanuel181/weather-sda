{% extends "base.html" %}

{% block title %}
  Weather + Chat + Forecast
{% endblock %}

{% block content %}
  <h1 class="mb-4">Check the Weather (No Refresh)</h1>

  <!-- Input group with manual entry, Get Weather, and Detect Location buttons -->
  <div class="d-flex mb-3" style="max-width: 400px;">
    <input type="text" id="cityInput"
           class="form-control animate__animated animate__bounceInLeft"
           placeholder="Enter city name" />
    <button id="getWeatherBtn" class="btn btn-primary animate__animated animate__bounceInRight ms-2">
      Get Weather
    </button>
    <button id="detectLocationBtn" class="btn btn-secondary ms-2">
      Detect Location
    </button>
  </div>

  <!-- Temperature unit toggle button (AJAX toggle, no refresh) -->
  <button id="toggleUnitBtn" class="btn btn-outline-info mb-3">
    Toggle °C/°F (Current: {{ temp_unit }})
  </button>

  <!-- Weather result with icon -->
  <div id="weatherResult" class="alert d-none" style="min-height: 50px;">
    <img id="weatherIcon" src="" alt="Weather Icon" style="display: none; vertical-align: middle; margin-right: 10px;">
    <span id="weatherText"></span>
  </div>

  <!-- Add to favorites form -->
  <form method="POST" action="{{ url_for('add_favorite') }}" style="display:none;" id="favoritesForm"
        class="animate__animated animate__zoomIn">
    <input type="hidden" name="favorite_city" id="favoriteCityInput" />
    <button type="submit" class="btn btn-warning">Add to Favorites</button>
  </form>

  <hr />

  <!-- 5-Day Forecast Chart (fixed width/height) -->
  <div id="forecastSection" style="display:none; margin-bottom:20px; width: 400px; height: 220px;">
    <h3 class="mb-3">5-Day Forecast</h3>
    <canvas id="forecastChart" width="400" height="200" style="width: 400px; height:200px;"></canvas>
  </div>

  <hr/>

  <!-- Real-Time Chat Section -->
  <div class="chat-section">
    <h2 class="mb-3">Simple Chat</h2>
    <div id="chatMessages" class="chat-messages mb-3 p-2"
         style="border: 1px solid #ddd; max-height: 200px; overflow-y: auto; border-radius: 5px;">
    </div>
    <div class="input-group" style="max-width: 400px;">
      <input type="text" id="chatInput" class="form-control" placeholder="Enter chat message..." />
      <button id="sendChatBtn" class="btn btn-success">
        Send
      </button>
    </div>
  </div>

  <!-- Toast Notification Markup -->
  <div class="position-fixed bottom-0 end-0 p-3" style="z-index: 1055">
    <div id="liveToast" class="toast" role="alert" aria-live="assertive" aria-atomic="true">
      <div class="toast-header">
        <strong class="me-auto">Notification</strong>
        <small>Now</small>
        <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
      </div>
      <div class="toast-body" id="toastBody"></div>
    </div>
  </div>

  <!-- Socket.IO client, Chart.js, and custom scripts -->
  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    let tempUnit = "{{ temp_unit }}"; // Temperature unit passed from the backend

  // 1) Socket.IO Setup
  var socket = io();
  socket.on('connect', function() {
    console.log('Connected to server with SID:', socket.id);
  });
  socket.on('connect_error', function(error) {
    console.error('Connection Error:', error);
  });
  socket.on('chat_message', function(data) {
    var chatBox = document.getElementById('chatMessages');
    var p = document.createElement('p');
    p.className = "animate__animated animate__fadeInUp";
    p.textContent = data.message;
    chatBox.appendChild(p);
    chatBox.scrollTop = chatBox.scrollHeight;
  });

      // 2) Attach click event listeners to buttons
      document.getElementById('getWeatherBtn').addEventListener("click", fetchWeather);
      document.getElementById('detectLocationBtn').addEventListener("click", detectLocation);
      document.getElementById('sendChatBtn').addEventListener("click", function() {
        var input = document.getElementById('chatInput');
        var msg = input.value.trim();
        if (msg) {
          socket.emit('chat_message', { text: msg });
          input.value = '';
        }
      });
      document.getElementById('toggleUnitBtn').addEventListener("click", toggleUnit);


    async function fetchWeather() {
      const cityInput = document.getElementById("cityInput");
      const city = cityInput.value.trim();
      if (!city) {
        showToast("Please enter a valid city.");
        return;
      }

      clearWeatherDisplay();
      setButtonLoading(true);

      try {
        const resp = await fetch(`/api/weather?city=${encodeURIComponent(city)}`);
        const data = await resp.json();
        if (data.error) {
          displayWeatherError(data.error);
        } else {
          displayWeatherData(data);
          await fetchForecast(data.city);
          showToast("Weather data fetched successfully!");
          fireConfetti();
        }
      } catch (err) {
        console.error("Request failed:", err);
        displayWeatherError(err.message);
      } finally {
        setButtonLoading(false);
      }
    }

    async function fetchForecast(city) {
      if (!city || city === "Your Location") {
        console.error("Invalid city for forecast request");
        return;
      }
      try {
        const resp = await fetch(`/api/forecast?city=${encodeURIComponent(city)}`);
        const data = await resp.json();
        if (data.error || !data.forecast) return;

        displayForecast(data.forecast);
      } catch (error) {
        console.error("Forecast fetch failed:", error);
      }
    }

    async function detectLocation() {
      if (!navigator.geolocation) {
        showToast("Geolocation is not supported by your browser.");
        return;
      }

      navigator.geolocation.getCurrentPosition(
        async function (position) {
          const { latitude: lat, longitude: lon } = position.coords;

          try {
            const geoResp = await fetch(`/api/reverse_geocode?lat=${lat}&lon=${lon}`);
            const geoData = await geoResp.json();

            if (geoData.error) {
              showToast("Could not detect location.");
              return;
            }

            const city = geoData.city;
            if (!city) {
              showToast("Unable to detect a valid location.");
              return;
            }

            document.getElementById("cityInput").value = city; // Update input with the actual city name

            // Fetch weather and forecast by coordinates
            await fetchWeatherByCoords(lat, lon, city);
          } catch (error) {
            console.error("Reverse geocoding failed:", error);
            showToast("Unable to retrieve location.");
          }
        },
        (error) => {
          console.error("Geolocation error:", error);
          showToast("Unable to retrieve location.");
        }
      );
    }

    async function toggleUnit() {
      try {
        const response = await fetch("/toggle_unit", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-Requested-With": "XMLHttpRequest",
          },
        });
        const data = await response.json();
        tempUnit = data.temp_unit;

        const toggleBtn = document.getElementById("toggleUnitBtn");
        if (toggleBtn) {
          toggleBtn.innerHTML = `Toggle °C/°F (Current: ${tempUnit})`;
        } else {
          console.warn("Toggle button not found in the DOM.");
        }

        // Refresh weather data for the currently entered city
        const city = document.getElementById("cityInput").value.trim();
        if (city) {
          fetchWeather();
        }
      } catch (error) {
        console.error("Toggle unit failed:", error);
        showToast("Error toggling unit");
      }
    }

    async function fetchWeatherByCoords(lat, lon, city) {
      clearWeatherDisplay();
      setButtonLoading(true);

      try {
        const resp = await fetch(`/api/weather?lat=${lat}&lon=${lon}`);
        const data = await resp.json();

        if (data.error) {
          displayWeatherError(data.error);
        } else {
          displayWeatherData(data);
          await fetchForecast(city); // Use the detected city for the forecast
          showToast("Weather data fetched successfully!");
          fireConfetti();
        }
      } catch (error) {
        console.error("Request failed:", error);
        displayWeatherError(error.message);
      } finally {
        setButtonLoading(false);
      }
    }

    // Utility Functions
    function clearWeatherDisplay() {
      document.getElementById("weatherResult").classList.add("d-none");
      document.getElementById("forecastSection").style.display = "none";
    }

    function displayWeatherData(data) {
      const weatherResult = document.getElementById("weatherResult");
      const weatherText = document.getElementById("weatherText");
      const weatherIcon = document.getElementById("weatherIcon");

      if (weatherText) {
        weatherText.innerHTML = `<strong>Weather for ${data.city}:</strong> ${data.weather_info}`;
      }

      if (data.icon && weatherIcon) {
        weatherIcon.src = `https://openweathermap.org/img/wn/${data.icon}@2x.png`;
        weatherIcon.style.display = "inline";
      }

      weatherResult.className = "alert alert-success animate__animated animate__fadeIn";
      weatherResult.classList.remove("d-none");

      const favoritesForm = document.getElementById("favoritesForm");
      if (favoritesForm) {
        favoritesForm.style.display = "block";
        document.getElementById("favoriteCityInput").value = data.city;
      }

      updateBackground(data.weather_main);
    }

    function displayForecast(forecast) {
      const forecastSection = document.getElementById("forecastSection");
      const chartCanvas = document.getElementById("forecastChart");
      const labels = forecast.map((item) => item.date);
      const temps = forecast.map((item) => item.temp);

      if (window.forecastChartInstance) {
        window.forecastChartInstance.destroy();
      }

      window.forecastChartInstance = new Chart(chartCanvas, {
        type: "line",
        data: {
          labels: labels,
          datasets: [
            {
              label: `Temperature (${tempUnit === "imperial" ? "°F" : "°C"})`,
              data: temps,
              borderColor: "rgba(54, 162, 235, 1)",
              backgroundColor: "rgba(54, 162, 235, 0.2)",
              fill: true,
            },
          ],
        },
        options: {
          responsive: false,
          maintainAspectRatio: false,
        },
      });

      forecastSection.style.display = "block";
    }

    function displayWeatherError(message) {
      const weatherResult = document.getElementById("weatherResult");
      weatherResult.textContent = `Error: ${message}`;
      weatherResult.classList.remove("d-none");
    }

    function showToast(message) {
      const toastBody = document.getElementById("toastBody");
      const toastEl = document.getElementById("liveToast");

      if (toastBody) toastBody.textContent = message;
      if (toastEl) new bootstrap.Toast(toastEl).show();
    }

    function setButtonLoading(isLoading) {
      const btn = document.getElementById("getWeatherBtn");

      if (!btn) return;
      btn.innerHTML = isLoading ? "Loading..." : "Get Weather";
      btn.disabled = isLoading;
    }

    function appendChatMessage(message) {
      const chatBox = document.getElementById("chatMessages");
      const p = document.createElement("p");
      p.className = "animate__animated animate__fadeInUp";
      p.textContent = message;
      chatBox.appendChild(p);
      chatBox.scrollTop = chatBox.scrollHeight;
    }

    function updateBackground(condition) {
      let bgColor = "";
      if (!condition) return;
      condition = condition.toLowerCase();
      if (condition.includes("clear")) {
        bgColor = "linear-gradient(135deg, #81ecec, #74b9ff)";
      } else if (condition.includes("cloud")) {
        bgColor = "linear-gradient(135deg, #dfe6e9, #b2bec3)";
      } else if (condition.includes("rain")) {
        bgColor = "linear-gradient(135deg, #74b9ff, #0984e3)";
      } else if (condition.includes("snow")) {
        bgColor = "linear-gradient(135deg, #dfe6e9, #ffffff)";
      } else {
        bgColor = "linear-gradient(135deg, #55efc4, #81ecec)";
      }
      document.body.style.background = bgColor;
    }

    function fireConfetti() {
  const duration = 1.5 * 1000; // Duration for the confetti effect in milliseconds
  const end = Date.now() + duration;

  (function frame() {
    confetti({
      particleCount: 5, // Number of particles per frame
      startVelocity: 30, // Initial velocity of particles
      spread: 360, // Spread of particles in degrees
      origin: { x: Math.random(), y: Math.random() * 0.2 }, // Origin position of the confetti
    });
    if (Date.now() < end) {
      requestAnimationFrame(frame); // Continue the animation until the duration ends
    }
  })();
}

  });
</script>


{% endblock %}